(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('proxy-compare')) :
  typeof define === 'function' && define.amd ? define(['exports', 'proxy-compare'], factory) :
  (global = global || self, factory(global.proxyMemoize = {}, global.proxyCompare));
})(this, (function (exports, proxyCompare) {
  // constants from proxy-compare
  var HAS_KEY_PROPERTY = 'h';
  var ALL_OWN_KEYS_PROPERTY = 'w';
  var HAS_OWN_KEY_PROPERTY = 'o';
  var KEYS_PROPERTY = 'k';
  var isObject = function isObject(x) {
    return typeof x === 'object' && x !== null;
  };
  var untrack = function untrack(x, seen) {
    if (!isObject(x)) return x;
    var untrackedObj = proxyCompare.getUntracked(x);
    if (untrackedObj !== null) {
      proxyCompare.trackMemo(x);
      return untrackedObj;
    }
    if (!seen.has(x)) {
      seen.add(x);
      Object.entries(x).forEach(function (_ref) {
        var k = _ref[0],
          v = _ref[1];
        var vv = untrack(v, seen);
        if (!Object.is(vv, v)) x[k] = vv;
      });
    }
    return x;
  };
  var touchAffected = function touchAffected(dst, src, affected) {
    var _used$HAS_KEY_PROPERT, _used$HAS_OWN_KEY_PRO, _used$KEYS_PROPERTY;
    if (!isObject(dst) || !isObject(src)) return;
    var used = affected.get(proxyCompare.getUntracked(src) || src);
    if (!used) return;
    (_used$HAS_KEY_PROPERT = used[HAS_KEY_PROPERTY]) == null ? void 0 : _used$HAS_KEY_PROPERT.forEach(function (key) {
      Reflect.has(dst, key);
    });
    if (used[ALL_OWN_KEYS_PROPERTY] === true) {
      Reflect.ownKeys(dst);
    }
    (_used$HAS_OWN_KEY_PRO = used[HAS_OWN_KEY_PROPERTY]) == null ? void 0 : _used$HAS_OWN_KEY_PRO.forEach(function (key) {
      Reflect.getOwnPropertyDescriptor(dst, key);
    });
    (_used$KEYS_PROPERTY = used[KEYS_PROPERTY]) == null ? void 0 : _used$KEYS_PROPERTY.forEach(function (key) {
      touchAffected(dst[key], src[key], affected);
    });
  };
  // properties
  var OBJ_PROPERTY = 'o';
  var RESULT_PROPERTY = 'r';
  var AFFECTED_PROPERTY = 'a';
  /**
   * Create a memoized function
   *
   * @example
   * import { memoize } from 'proxy-memoize';
   *
   * const fn = memoize(obj => ({ sum: obj.a + obj.b, diff: obj.a - obj.b }));
   *
   * @param options
   * @param options.size - (default: 1)
   * @param options.noWeakMap - disable tier-1 cache (default: false)
   */
  function memoize(fn, options) {
    var _options$size;
    var memoListHead = 0;
    var size = (_options$size = options == null ? void 0 : options.size) != null ? _options$size : 1;
    var memoList = [];
    var resultCache = options != null && options.noWeakMap ? null : new WeakMap();
    var memoizedFn = function memoizedFn(obj) {
      var _entry;
      var cache = resultCache == null ? void 0 : resultCache.get(obj);
      if (cache) {
        return cache[RESULT_PROPERTY];
      }
      for (var i = 0; i < size; i += 1) {
        var memo = memoList[(memoListHead + i) % size];
        if (!memo) break;
        if (!proxyCompare.isChanged(memo[OBJ_PROPERTY], obj, memo[AFFECTED_PROPERTY], new WeakMap())) {
          touchAffected(obj, memo[OBJ_PROPERTY], memo[AFFECTED_PROPERTY]);
          resultCache == null ? void 0 : resultCache.set(obj, memo);
          return memo[RESULT_PROPERTY];
        }
      }
      var affected = new WeakMap();
      var proxy = proxyCompare.createProxy(obj, affected);
      var result = untrack(fn(proxy), new Set());
      touchAffected(obj, obj, affected);
      var entry = (_entry = {}, _entry[OBJ_PROPERTY] = obj, _entry[RESULT_PROPERTY] = result, _entry[AFFECTED_PROPERTY] = affected, _entry);
      memoListHead = (memoListHead - 1 + size) % size;
      memoList[memoListHead] = entry;
      resultCache == null ? void 0 : resultCache.set(obj, entry);
      return result;
    };
    return memoizedFn;
  }

  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  /**
   * Create a memoized function with args
   *
   * @example
   * import { memoizeWithArgs } from 'proxy-memoize';
   *
   * const fn = memoizeWithArgs((a, b) => ({ sum: a.v + b.v, diff: a.v - b.v }));
   *
   * @param options
   * @param options.size - (default: 1)
   */
  var memoizeWithArgs = function memoizeWithArgs(fnWithArgs, options) {
    var fn = memoize(function (args) {
      return fnWithArgs.apply(void 0, args);
    }, _extends({}, options, {
      noWeakMap: true
    }));
    return function () {
      return fn([].slice.call(arguments));
    };
  };

  Object.defineProperty(exports, 'getUntracked', {
    enumerable: true,
    get: function () { return proxyCompare.getUntracked; }
  });
  Object.defineProperty(exports, 'replaceNewProxy', {
    enumerable: true,
    get: function () { return proxyCompare.replaceNewProxy; }
  });
  exports.memoize = memoize;
  exports.memoizeWithArgs = memoizeWithArgs;

}));
//# sourceMappingURL=index.umd.js.map
