import { isChanged, createProxy, getUntracked, trackMemo } from 'proxy-compare';
export { getUntracked, replaceNewProxy } from 'proxy-compare';

// constants from proxy-compare
const HAS_KEY_PROPERTY = 'h';
const ALL_OWN_KEYS_PROPERTY = 'w';
const HAS_OWN_KEY_PROPERTY = 'o';
const KEYS_PROPERTY = 'k';
const isObject = x => typeof x === 'object' && x !== null;
const untrack = (x, seen) => {
  if (!isObject(x)) return x;
  const untrackedObj = getUntracked(x);
  if (untrackedObj !== null) {
    trackMemo(x);
    return untrackedObj;
  }
  if (!seen.has(x)) {
    seen.add(x);
    Object.entries(x).forEach(([k, v]) => {
      const vv = untrack(v, seen);
      if (!Object.is(vv, v)) x[k] = vv;
    });
  }
  return x;
};
const touchAffected = (dst, src, affected) => {
  var _used$HAS_KEY_PROPERT, _used$HAS_OWN_KEY_PRO, _used$KEYS_PROPERTY;
  if (!isObject(dst) || !isObject(src)) return;
  const used = affected.get(getUntracked(src) || src);
  if (!used) return;
  (_used$HAS_KEY_PROPERT = used[HAS_KEY_PROPERTY]) == null ? void 0 : _used$HAS_KEY_PROPERT.forEach(key => {
    Reflect.has(dst, key);
  });
  if (used[ALL_OWN_KEYS_PROPERTY] === true) {
    Reflect.ownKeys(dst);
  }
  (_used$HAS_OWN_KEY_PRO = used[HAS_OWN_KEY_PROPERTY]) == null ? void 0 : _used$HAS_OWN_KEY_PRO.forEach(key => {
    Reflect.getOwnPropertyDescriptor(dst, key);
  });
  (_used$KEYS_PROPERTY = used[KEYS_PROPERTY]) == null ? void 0 : _used$KEYS_PROPERTY.forEach(key => {
    touchAffected(dst[key], src[key], affected);
  });
};
// properties
const OBJ_PROPERTY = 'o';
const RESULT_PROPERTY = 'r';
const AFFECTED_PROPERTY = 'a';
/**
 * Create a memoized function
 *
 * @example
 * import { memoize } from 'proxy-memoize';
 *
 * const fn = memoize(obj => ({ sum: obj.a + obj.b, diff: obj.a - obj.b }));
 *
 * @param options
 * @param options.size - (default: 1)
 * @param options.noWeakMap - disable tier-1 cache (default: false)
 */
function memoize(fn, options) {
  var _options$size;
  let memoListHead = 0;
  const size = (_options$size = options == null ? void 0 : options.size) != null ? _options$size : 1;
  const memoList = [];
  const resultCache = options != null && options.noWeakMap ? null : new WeakMap();
  const memoizedFn = obj => {
    const cache = resultCache == null ? void 0 : resultCache.get(obj);
    if (cache) {
      return cache[RESULT_PROPERTY];
    }
    for (let i = 0; i < size; i += 1) {
      const memo = memoList[(memoListHead + i) % size];
      if (!memo) break;
      if (!isChanged(memo[OBJ_PROPERTY], obj, memo[AFFECTED_PROPERTY], new WeakMap())) {
        touchAffected(obj, memo[OBJ_PROPERTY], memo[AFFECTED_PROPERTY]);
        resultCache == null ? void 0 : resultCache.set(obj, memo);
        return memo[RESULT_PROPERTY];
      }
    }
    const affected = new WeakMap();
    const proxy = createProxy(obj, affected);
    const result = untrack(fn(proxy), new Set());
    touchAffected(obj, obj, affected);
    const entry = {
      [OBJ_PROPERTY]: obj,
      [RESULT_PROPERTY]: result,
      [AFFECTED_PROPERTY]: affected
    };
    memoListHead = (memoListHead - 1 + size) % size;
    memoList[memoListHead] = entry;
    resultCache == null ? void 0 : resultCache.set(obj, entry);
    return result;
  };
  return memoizedFn;
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

/**
 * Create a memoized function with args
 *
 * @example
 * import { memoizeWithArgs } from 'proxy-memoize';
 *
 * const fn = memoizeWithArgs((a, b) => ({ sum: a.v + b.v, diff: a.v - b.v }));
 *
 * @param options
 * @param options.size - (default: 1)
 */
const memoizeWithArgs = (fnWithArgs, options) => {
  const fn = memoize(args => fnWithArgs(...args), _extends({}, options, {
    noWeakMap: true
  }));
  return (...args) => fn(args);
};

export { memoize, memoizeWithArgs };
//# sourceMappingURL=index.modern.mjs.map
